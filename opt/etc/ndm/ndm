#!/bin/sh
#------------------------------------------------------------------------------
#	ПАКЕТ КВАС
#------------------------------------------------------------------------------
#
#	Данный файл служит библиотекой переменных среды и функций,
#	которые используются в событийном пакете ndm
#	https://github.com/ndmsystems/packages/wiki/Opkg-Component
#
# ------------------------------------------------------------------------------
#	Разработчик: mail@zeleza.ru
#	Дата создания: 13/09/2022
#	Лицензия: Apache License 2.0
# ------------------------------------------------------------------------------------------

# ------------------------------------------------------------------------------------------
# Подключаем функции логирования
. /opt/apps/kvas/bin/libs/main
# ------------------------------------------------------------------------------------------

# имя таблицы для ipset

TABLE_ID=1001
PRIORITY=1778
MARK_NUM=0xd1000
DNS_PORT=9753

IPSET_RESERVED=KVAS_RESERVED

CHAIN_DNS=KVAS_DNS
TABLE_DNS=nat

CHAIN_MARK_TO_TABLE=KVAS_MARK_TO_TABLE
TABLE_MARK_TO_TABLE=mangle
#ToDo: попробовать вышестоящее и на отключенном ускорении

CHAIN_DNAT_TO_PORT=KVAS_DNAT_TO_PORT
TABLE_DNAT_TO_PORT=nat
#ToDo: попробовать -p udp -j TPROXY --on-port "${port}" --tproxy-mark 0x01/0x01
CHAIN_TPROXY_TO_PORT=KVAS_TPROXY_TO_PORT
TABLE_TPROXY_TO_PORT=mangle


IPv4='IPv4::'
IPv6='IPv6::'



ip4() (/opt/sbin/ip -4 "$@")
ip4tables() (/opt/sbin/iptables -C "$@" &>/dev/null || /opt/sbin/iptables -A "$@")
iptab() (/opt/sbin/iptables "$@")
ip4save() (/opt/sbin/iptables-save | grep -vE '\-A _')
get_gw4()([ "${1}" ] && /opt/sbin/ip addr show "${1}" | grep -Po "(?<=inet ).*(?=/)")
is_os_4()([[ "$(version_os)" =~ 4.* ]])

get_model() {
	if [ -n "${1}" ]; then
		local version_data="${1}"
	else
		local version_data=$(ndmc -c show version)
	fi

	echo "${version_data}" | grep -F 'model' | head -1 | cut -d: -f2 | xargs
}

get_version() {
	if [ -n "${1}" ]; then
		local version_data="${1}"
	else
		local version_data=$(ndmc -c show version)
	fi

	echo "${version_data}" | grep -F 'version' | grep -oE '[0-9][0-9\.]*[0-9]' | head -1
}

version_os() {
	local versions_data=$(ndmc -c show version)

	# пробуем использовать version только в блоке с ndw4
	local version_ndw4=$(echo "${versions_data}" | grep -zoP '(?s)ndw4:.+?\n\n')
	if [ -n "${version_ndw4}" ]; then
		version_ndw4=$(get_version "${version_ndw4}")
		if [ -n "${version_ndw4}" ]; then
			echo "${version_ndw4}"
			return
		fi
	fi

	# иначе любой
	echo $(get_version "${versions_data}")
}


#как пример гостевая сеть br3, которой необходимо обеспечить доступ к VPN
inface_cli()(get_config_value "INFACE_CLI")
inface_ent()(get_config_value "INFACE_ENT")
inface_gw4()(get_gw4 "$(inface_ent)")

inface_guest_gw4()(get_gw4 "${1}")
guest_net()(echo "$(inface_guest_gw4 "${1}" | cut -d'.' -f1-3).0/24")

# ------------------------------------------------------------------------------------------
# проверка на доступность программного и аппаратного ускорения
# ------------------------------------------------------------------------------------------
fastnet_support()(curl -s localhost:79/rci/show/version | grep -q ppe)
fast_hw_enabled()(is_os_4 && ask=enable || ask=false; ! curl -s localhost:79/rci/show/rc/ppe | grep hardware -C1 | grep -q ${ask})
fast_sw_enabled()(is_os_4 && ask=enable || ask=false; ! curl -s localhost:79/rci/show/rc/ppe | grep software -C1 | grep -q ${ask})
fastnet_enabled()(fast_hw_enabled || fast_sw_enabled)


# ------------------------------------------------------------------------------------------
#
# Функции для работы с iptables универсальные, подходящие и для IPv6
#
# ------------------------------------------------------------------------------------------

iptables__get_subrule_for_net() {
	if [ -z "${1}" ] ; then
		error "[${FUNCNAME}] Не задан обязательный аргумент — сетевой интерфейс"
		return
	fi
	local net_interface="${1}"

	if [ "${net_interface}" != 'ikev2' ] ; then
		echo "-i ${net_interface}"
		return
	fi

	net_interface=$(get_entware_ikev2_inface)
	local subrule="-i ${net_interface}"

	# если свой виртуальный интерфейс
	if echo "${net_interface}" | grep -Fq 'xfrms' ; then
		echo "${subrule}"
		return
	fi

	echo "-s $(get_ikev2_net_pool) ${subrule}"
}

# удаляет правило, полученное из iptables-save
iptables__delete_rule() {
	if [ -z "${1}" ] ; then
		error "[${FUNCNAME}] Не задан обязательный аргумент — таблица"
		return
	fi
	table="${1}"

	if [ -z "${2}" ] ; then
		error "[${FUNCNAME}] Не задан обязательный аргумент — правило"
		return
	fi
	rule="${2}"

	if [ "${rule:0:3}" != '-A ' ]; then
		return
	fi

	iptables -t "${table}" -D $(echo "${rule:3}")
}

# удаляет правила, получаемые по критерию
iptables__delete_rules() {
	if [ -z "${1}" ] ; then
		error "[${FUNCNAME}] Не задан обязательный аргумент — таблица"
		return
	fi
	table="${1}"

	if [ -z "${2}" ] ; then
		error "[${FUNCNAME}] Не задан обязательный аргумент — фильтр"
		return
	fi
	filter="${2}"

	local rules=$(iptables-save -t "${table}" | grep -F -- "${filter}")
	if [ -z "${rules}" ] ; then
		return
	fi

	log_warning "Удаляем iptables правила в ${table} по критерию ${filter}"

	echo "${rules}" | while IFS= read -r rule ; do
		iptables__delete_rule "${table}" "${rule}"
	done
}


# ------------------------------------------------------------------------------------------
#
# Функции для работы с IPSet
# Пока что все помечены как ip4, по мере адаптации префикс удалять
#
# ------------------------------------------------------------------------------------------

ip4__ipset__is_exist() {
	if [ -z "${1}" ] ; then
		error "[${FUNCNAME}] Не задан обязательный аргумент — имя"
		return
	fi
	local ipset_name="${1}"

	! ipset list "${ipset_name}" 2>&1 | grep -q 'name does not exist'
}

ip4__ipset__create() {
	if [ -z "${1}" ] ; then
		error "[${FUNCNAME}] Не задан обязательный аргумент — имя"
		return
	fi
	local ipset_name="${1}"

	if ip4__ipset__is_exist "${ipset_name}"; then
		return
	fi

	if [ -n "${2}" ] ; then
		local ttl="${2}"

		local subcomand=" timeout ${ttl}"
		local submessage=" с таймаутом ${ttl}"
	else
		local subcomand=''
		local submessage=''
	fi

	log_warning "Cоздаём набор IP ${ipset_name}${submessage}"

	ipset create "${ipset_name}" hash:net family inet -exist$(echo "${subcomand}") \
	 || {
		error "[${FUNCNAME}] Ошибка при создании набора IP ${ipset_name}${submessage}"
	}
}

# Для списка условной маршрутизации
ip4__ipset__create_list() {
	ip4__ipset__create "${IPSET_TABLE_NAME}" "$(get_config_value TTL_TIMEOUT)"
}

#TODO: сменить в других файлах обращение на новую обёртку
ip4set_create_table() {
	ip4__ipset__create_list
}

# Для постоянного списка исключаемых сетей
ip4__ipset__fill_reserved() {
	if ip4__ipset__is_exist "${IPSET_RESERVED}"; then
		return
	fi

	ip4__ipset__create "${IPSET_RESERVED}"

	while read -r ip_or_range || [ -n "${ip_or_range}" ]; do
		# пропускаем строки с комментариями
		[ "${ip_or_range:0:1}" = '#' ] && continue
		# удаляем из строк комментарии - все что встречается после символа # и сам символ
		# удаляем пробелы
		ip_or_range=$(echo "${ip_or_range}" | sed 's/#.*$//g' | tr -s ' ' )

		ipset -exist add "${IPSET_RESERVED}" "${ip_or_range}"
	done < "${FILE_RESERVED}"
}

ip4__ipset__destroy() {
	if [ -z "${1}" ] ; then
		error "[${FUNCNAME}] Не задан обязательный аргумент — имя"
		return
	fi
	local ipset_name="${1}"

	if ! ip4__ipset__is_exist "${ipset_name}"; then
		return
	fi

	log_warning "Уничтожаем набор IP ${ipset_name}"

	#ipset flush "${ipset_name}"
	ipset destroy "${ipset_name}" \
	 || {
		error "[${FUNCNAME}] Ошибка при уничтожении набора IP ${ipset_name}"
	}
}

# Для списка условной маршрутизации
ip4__ipset__destroy_list() {
	ip4__ipset__destroy "${IPSET_TABLE_NAME}"
}

# Для постоянного списка исключаемых сетей
ip4__ipset__destroy_reserved() {
	ip4__ipset__destroy "${IPSET_RESERVED}"
}


# ------------------------------------------------------------------------------------------
#
# Общие обёртки для цепочек
#
# ------------------------------------------------------------------------------------------

ip4__chain__is_exist() {
	if [ -z "${1}" ] ; then
		error "[${FUNCNAME}] Не задан обязательный аргумент — таблица"
		return
	fi
	table="${1}"

	if [ -z "${2}" ] ; then
		error "[${FUNCNAME}] Не задан обязательный аргумент — цепочка"
		return
	fi
	chain_name="${2}"

	iptables-save -t "${table}" | grep -Fq "${chain_name}"
}

ip4__chain__exclude_source_by_config() {
	if [ -z "${1}" ] ; then
		error "[${FUNCNAME}] Не задан обязательный аргумент — таблица"
		return
	fi
	table="${1}"

	if [ -z "${2}" ] ; then
		error "[${FUNCNAME}] Не задан обязательный аргумент — цепочка"
		return
	fi
	chain_name="${2}"

	local values=$(get_config_value 'route_excluded_ip')
	if [ -z "${values}" ] ; then
		return
	fi
	local regexp_ip_or_range=$(get_regexp_ip_or_range)

	for ip_or_range in ${values} ; do
		if ! echo "${ip_or_range}" | grep -qE "${regexp_ip_or_range}" ; then
			continue
		fi

		iptables -A "${chain_name}" -w -t "${table}" -s "${ip_or_range}" -j RETURN
	done
}

# Создаёт (если нет) цепочку для роутинга данных
ip4__chain__create_for_data() {
	if [ -z "${1}" ] ; then
		error "[${FUNCNAME}] Не задан обязательный аргумент — таблица"
		return
	fi
	table="${1}"

	if [ -z "${2}" ] ; then
		error "[${FUNCNAME}] Не задан обязательный аргумент — цепочка"
		return
	fi
	chain_name="${2}"

	if ip4__chain__is_exist "${table}" "${chain_name}" ; then
		return
	fi

	log_warning "Создание цепочки ${chain_name} в ${table} для перенаправления данных"

	iptables -N "${chain_name}" -w -t "${table}"

	ip4__chain__exclude_source_by_config "${table}" "${chain_name}"

	ip4__ipset__fill_reserved
	iptables -A "${chain_name}" -w -t "${table}" -m set --match-set "${IPSET_RESERVED}" dst -j RETURN

	# если цепочка данных будет подключена выше DNS, то она может 
	# перехватить направленный вовне трафик
	for protocol in udp tcp ; do
		iptables -A "${chain_name}" -w -t "${table}" -p "${protocol}" --dport 53 -j RETURN
	done
}

ip4__chain__delete() {
	if [ -z "${1}" ] ; then
		error "[${FUNCNAME}] Не задан обязательный аргумент — таблица"
		return
	fi
	table="${1}"

	if [ -z "${2}" ] ; then
		error "[${FUNCNAME}] Не задан обязательный аргумент — цепочка"
		return
	fi
	chain_name="${2}"

	if ! ip4__chain__is_exist "${table}" "${chain_name}"; then
		return
	fi

	log_warning "Удаление цепочки ${chain_name} в ${table}"

	iptables -F "${chain_name}" -t "${table}"
	iptables -X "${chain_name}" -t "${table}"
}

# удаляем входы в цепочку
ip4__chain__delete_jump() {
	if [ -z "${1}" ] ; then
		error "[${FUNCNAME}] Не задан обязательный аргумент — таблица"
		return
	fi
	table="${1}"

	if [ -z "${2}" ] ; then
		error "[${FUNCNAME}] Не задан обязательный аргумент — цепочка"
		return
	fi
	chain_name="${2}"

	iptables__delete_rules "${table}" "-j ${chain_name}"
}


# ------------------------------------------------------------------------------------------
#
# Создание цепочек
#
# ------------------------------------------------------------------------------------------

ip4__proxy__create_chain() {
	if [ -z "${1}" ] ; then
		error "[${FUNCNAME}] Не задан обязательный аргумент — таблица"
		return
	fi
	table="${1}"

	if [ -z "${2}" ] ; then
		error "[${FUNCNAME}] Не задан обязательный аргумент — цепочка"
		return
	fi
	chain_name="${2}"

	if [ -z "${3}" ] ; then
		error "[${FUNCNAME}] Не задан обязательный аргумент — порт"
		return
	fi
	port="${3}"

	ip="${4}"

	{
		if ip4__ipset__is_exist "${table}" "${chain_name}" ; then
			return
		fi

		ip4__chain__create_for_data "${table}" "${chain_name}"

		if [ -n "${ip}" ] ; then
			# Исключаем обращения к собственному адресу
			ipset -exist add "${IPSET_RESERVED}" "${ip}"
		fi

		for protocol in udp tcp ; do
			iptables -A "${chain_name}" -t "${table}" -p "${protocol}" -j REDIRECT --to-port "${port}"
		done
	} &>/dev/null || error "[${FUNCNAME}] Возникли ошибки при установке правил трафика для прокси"
}

ip4__shadowsocks__create_chain() {
	ip=$(cat < /opt/etc/shadowsocks.json | grep 'server":' | tr -d '" ,' | cut -d':' -f2 )
	proxy_port=$(get_config_value SSR_DNS_PORT)

	ip4__proxy__create_chain "${TABLE_DNAT_TO_PORT}" "${CHAIN_DNAT_TO_PORT}" "${proxy_port}" "${ip}"
}

#ToDo: доделать для VLESS
ip4__vless__create_chain() {
	ip4__proxy__create_chain "${TABLE_DNAT_TO_PORT}" "${CHAIN_DNAT_TO_PORT}" "${proxy_port}"
}

# когда ускорение подключено
ip4__vpn_fast__create_chain() {
	{
		if ip4__ipset__is_exist "${TABLE_MARK_TO_TABLE}" "${CHAIN_MARK_TO_TABLE}" ; then
			return
		fi

		ip4__chain__create_for_data "${TABLE_MARK_TO_TABLE}" "${CHAIN_MARK_TO_TABLE}"

		#ToDo: именно здесь надо автостартовать таблицы, их ручной старт нужно везде удалить
		# ведь только после завершения этой цепочки таблица нужна и сможет получить трафик
		#ip4_add_route_table
		#ip4_rule_set_priority

		iptables -A "${CHAIN_MARK_TO_TABLE}" -t "${TABLE_MARK_TO_TABLE}" -j CONNMARK --restore-mark
		iptables -A "${CHAIN_MARK_TO_TABLE}" -t "${TABLE_MARK_TO_TABLE}" -m mark --mark ${MARK_NUM} -j RETURN
		iptables -A "${CHAIN_MARK_TO_TABLE}" -t "${TABLE_MARK_TO_TABLE}" --syn -j MARK --set-mark ${MARK_NUM}
		iptables -A "${CHAIN_MARK_TO_TABLE}" -t "${TABLE_MARK_TO_TABLE}" -m conntrack --ctstate NEW -j MARK --set-mark ${MARK_NUM}
		iptables -A "${CHAIN_MARK_TO_TABLE}" -t "${TABLE_MARK_TO_TABLE}" -j CONNMARK --save-mark
	} &>/dev/null || error "[${FUNCNAME}] Возникли ошибки во время маркировки трафика для VPN при включенном ускорении"
}

# когда программное и аппаратное ускорение отключено
ip4__vpn_nofast__set_rules() {
	{
		#ToDo: должны работать таблицы или переписать на цепочки
		log_warning 'Маркировка трафика для VPN при отключенном ускорении'

		ip4__ipset__create_list
		# правило не переписывалось, таким и было
		ip4tables PREROUTING -t "${TABLE_MARK_TO_TABLE}" -i "$(inface_ent)" -m set --match-set ${IPSET_TABLE_NAME} dst -j MARK --set-mark ${MARK_NUM}
	} &>/dev/null || error "[${FUNCNAME}] Возникли ошибки во время маркировки трафика для VPN при отключенном ускорении"
}


# ------------------------------------------------------------------------------------------
#
# Подключение домашней сети сделано отдельно
# В идеале должна быть отключаема, как гостевые
#
# ------------------------------------------------------------------------------------------

ip4__dns__del_routing_for_home() {
	ip4__dns__del_routing "-i $(get_local_inface)"
}

ip4__dns__add_routing_for_home() {
	ip4__dns__add_routing "-i $(get_local_inface)"
}

ip4__add_routing_for_home() {
	if [ -z "${1}" ] ; then
		error "[${FUNCNAME}] Не задан обязательный аргумент — таблица"
		return
	fi
	table="${1}"

	if [ -z "${2}" ] ; then
		error "[${FUNCNAME}] Не задан обязательный аргумент — цепочка"
		return
	fi
	chain_name="${2}"

	#ToDo: использовать обёртку, а не код дальше

	local net_interface=$(get_local_inface)

	if iptables-save | grep -F 'PREROUTING' | grep -F "${net_interface}" | grep -F "${IPSET_TABLE_NAME}" | grep -Fq "${chain_name}" ; then
		return
	fi

	log_warning "Подключение перенаправления трафика для домашней сети в тоннель ${3}"

	ip4__ipset__create_list
	iptables -A PREROUTING -w -t "${table}" -i "${net_interface}" -m set --match-set "${IPSET_TABLE_NAME}" dst -j "${chain_name}"
}

ip4__shadowsocks__add_routing_for_home() {
	ip4__add_routing_for_home "${TABLE_DNAT_TO_PORT}" "${CHAIN_DNAT_TO_PORT}" 'ShadowSocks'
}

ip4__vless__add_routing_for_home() {
	ip4__add_routing_for_home "${TABLE_DNAT_TO_PORT}" "${CHAIN_DNAT_TO_PORT}" 'VLESS'
}

# когда ускорение подключено
ip4__vpn_fast__add_routing_for_home() {
	ip4__add_routing_for_home "${TABLE_MARK_TO_TABLE}" "${CHAIN_MARK_TO_TABLE}" 'VPN со включенным ускорением'
}


# ------------------------------------------------------------------------------------------
#
# Подключение и отключение перехвата DNS
#
# ------------------------------------------------------------------------------------------

# Создаёт (если нет) цепочку для DNS редиректа
ip4__dns__create_chain() {
	if iptables-save | grep -Fq "${CHAIN_DNS}"; then
		return
	fi

	log_warning 'Создание цепочки для DNS перенаправления'

	iptables -N "${CHAIN_DNS}" -w -t "${TABLE_DNS}"

	ip4__chain__exclude_source_by_config "${TABLE_DNS}" "${CHAIN_DNS}"

	for protocol in udp tcp ; do
		iptables -A "${CHAIN_DNS}" -t "${TABLE_DNS}" -p "${protocol}" --dport 53 -j DNAT --to-destination 127.0.0.1:"${DNS_PORT}"
	done
}

# Возвращает номер (в nat PREROUTING) по куску правила
#Example input param: NDM_UPNP_REDIRECT_SYS
ip4__get_rulenum() {
	if [ -z "${1}" ]; then
		error "[${FUNCNAME}] Не передан обязательный параметр — правило для поиска"
		return
	fi
	local find="${1}"

	# если потребуются другие таблицы или цепочки, можно сделать их входящими параметрами
	local table='nat'
	local chain='PREROUTING'

	echo $(iptables-save -t "${table}" | grep -F "${chain}" | grep -vF :"${chain}" \
	 | grep -nF -- "${find}" | head -n 1 | grep -oE '^[0-9]+')
}

# Возвращает номер (в PREROUTING) для DNS-правил
ip4__dns__get_rulenum() {
	# вместо NDM_DNS_REDIRECT
	local rulenum=$(ip4__get_rulenum 'NDM_DNS_REDIRECT')
	if [ -n "${rulenum}" ]; then
		echo "${rulenum}"
		return
	fi

	# после NDM_DNAT
	local rulenum=$(ip4__get_rulenum 'NDM_DNAT')
	if [ -n "${rulenum}" ]; then
		echo $((rulenum + 1))
		return
	fi

	# высший приоритет
	# если DNS перехват не будет работать, удаляем вышестоящее
	echo '1'
}

# Перенаправляем dns-запросы в dnsmasq
#Example input param:-s 192.168.3.0/24 -i eth3
#Example input param:-i sstp+
ip4__dns__add_routing() {
	if [ -n "${1}" ]; then
		local iptables_filter=$(echo "${1}" | xargs)
		local submessage=" по критерию ${iptables_filter}"
		iptables_filter=" ${iptables_filter}"
	else
		local iptables_filter=''
		local submessage=''
	fi

	if iptables-save | grep -F 'PREROUTING' | grep -F -- "${iptables_filter}" | grep -Fq "${CHAIN_DNS}" ; then
		return
	fi
	local rulenum=$(ip4__dns__get_rulenum)

	log_warning "Подключение DNS перенаправления с приоритетом ${rulenum}${submessage}"

	# после включения редиректа DNS ipset начнёт заполняться
	# нужно его создать автоматически для DNSMasq
	ip4__ipset__create_list

	ip4__dns__create_chain
	# без echo дублирование пробелов (что даёт warning и проблему наличия)
	iptables -I PREROUTING "${rulenum}" -w -t "${TABLE_DNS}"$(echo "${iptables_filter}") -j "${CHAIN_DNS}"
}

# Отключение перехвата dns-запросов в dnsmasq
#Example input param:-s 192.168.3.0/24 -i eth3
#Example input param:-i sstp+
ip4__dns__delete_routing() {
	if [ -n "${1}" ]; then
		local iptables_filter=$(echo "${1}" | xargs)
		local submessage=" по критерию ${iptables_filter}"
		iptables_filter=" ${iptables_filter}"
	else
		local iptables_filter=''
		local submessage=''
	fi

	if ! iptables-save | grep -F 'PREROUTING' | grep -F -- "${iptables_filter}" | grep -Fq "${CHAIN_DNS}" ; then
		return
	fi

	log_warning "Отключение DNS перенаправления${submessage}"

	# без echo дублирование пробелов (что даёт warning и проблему наличия)
	iptables -D PREROUTING -t "${TABLE_DNS}"$(echo "${iptables_filter}") -j "${CHAIN_DNS}"
}


# ------------------------------------------------------------------------------------------
#
# Подключение и отключение других сетей
#
# ------------------------------------------------------------------------------------------

get_guest_net() {
	# ip addr show "${1}" | grep global | sed 's/^.*inet \(.*\).*/\1/' | cut -d' ' -f1
	/opt/sbin/ip addr show "${1}" | grep global | sed 's|^.*inet \([0-9\.\/]*\).*|\1|' | sed 's|[0-9]*\/|0\/|'
}

# Получение маски локальной подсети клиентов IKEv2
#Example: 192.168.3.0/24
get_ikev2_net_pool() {
	ikev2_settings=$(curl -s "${LOCALHOST_IP}:79/rci/crypto/virtual-ip-server-ikev2")
	pool_start=$(echo "${ikev2_settings}" | grep pool-start | cut -d':' -f2 | sed 's/[\,\" ]//g;')
	echo "${pool_start}" | sed 's/\.[0-9]\{1,3\}$/.0\/24/'
}

ip4__add_routing_by_list_for_net() {
	local net_interface="${1}"
	if [ -z "${net_interface}" ] ; then
		error "[${FUNCNAME}] Не передан обязательный параметр — имя интерфейса"
		exit 1
	fi

	iptables_filter=$(iptables__get_subrule_for_net "${net_interface}")

	ip4__dns__add_routing "${iptables_filter}"

	if is_proxy_enabled ; then
		if iptables-save | grep -F 'PREROUTING' | grep -F -- "${iptables_filter}" | grep -F "${IPSET_TABLE_NAME}" | grep -Fq "${CHAIN_DNAT_TO_PORT}" ; then
			return
		fi
		log_warning "Подключаем правила гостевого трафика для прокси по критерию ${iptables_filter}"

		ip4__ipset__create_list
		iptables -A PREROUTING -w -t "${TABLE_DNAT_TO_PORT}" $(echo "${iptables_filter}") -m set --match-set "${IPSET_TABLE_NAME}" dst -j "${CHAIN_DNAT_TO_PORT}"

	elif fastnet_enabled ; then
		if iptables-save | grep -F 'PREROUTING' | grep -F -- "${iptables_filter}" | grep -F "${IPSET_TABLE_NAME}" | grep -Fq "${CHAIN_MARK_TO_TABLE}" ; then
			return
		fi
		log_warning "Подключаем правила гостевого трафика для VPN с ускорением по критерию ${iptables_filter}"

		ip4__ipset__create_list
		iptables -A PREROUTING -w -t "${TABLE_MARK_TO_TABLE}" $(echo "${iptables_filter}") -m set --match-set "${IPSET_TABLE_NAME}" dst -j "${CHAIN_MARK_TO_TABLE}"

	else
		# на выходе не доступен i
		if [ "${net_interface}" = 'ikev2' ] ; then
			local net_pool=$(get_ikev2_net_pool)
		else
			local net_pool=$(get_guest_net "${net_interface}")
		fi
		net_interface=$(get_external_interface)

		# случай основного VPN и отключенного ускорения требует дополнительной проверки
		# но именно таким код был изначально, т.е. он точно не "ухудшится"
		if iptables-save | grep -F 'POSTROUTING' | grep -F "${net_pool}" | grep -F "${net_interface}" | grep -Fq 'MASQUERADE' ; then
			return
		fi
		log_warning "Подключаем правила гостевого трафика для VPN без ускорения по критерию ${iptables_filter}"

		iptables -A POSTROUTING -w -t nat -s "${net_pool}" -o "${net_interface}" -j MASQUERADE
	fi
}

ip4__del_routing_by_list_for_net() {
	local net_interface="${1}"
	if [ -z "${net_interface}" ] ; then
		error "[${FUNCNAME}] Отсутствует обязательный параметр — имя сетевого интерфейса"
		exit 1
	fi

	iptables_filter=$(iptables__get_subrule_for_net "${net_interface}")

	ip4__dns__delete_routing "${iptables_filter}"

	if is_proxy_enabled ; then
		if ! iptables-save | grep -F 'PREROUTING' | grep -F -- "${iptables_filter}" | grep -F "${IPSET_TABLE_NAME}" | grep -Fq "${CHAIN_DNAT_TO_PORT}" ; then
			return
		fi
		log_warning "Отключаем правила гостевого трафика для прокси по критерию ${iptables_filter}"

		iptables -D PREROUTING -t "${TABLE_DNAT_TO_PORT}" $(echo "${iptables_filter}") -m set --match-set "${IPSET_TABLE_NAME}" dst -j "${CHAIN_DNAT_TO_PORT}"

	elif fastnet_enabled ; then
		if ! iptables-save | grep -F 'PREROUTING' | grep -F -- "${iptables_filter}" | grep -F "${IPSET_TABLE_NAME}" | grep -Fq "${CHAIN_MARK_TO_TABLE}" ; then
			return
		fi
		log_warning "Отключаем правила гостевого трафика для VPN с ускорением по критерию ${iptables_filter}"

		iptables -D PREROUTING -t "${TABLE_MARK_TO_TABLE}" $(echo "${iptables_filter}") -m set --match-set "${IPSET_TABLE_NAME}" dst -j "${CHAIN_MARK_TO_TABLE}"

	else
		# на выходе не доступен i
		if [ "${net_interface}" = 'ikev2' ] ; then
			local net_pool=$(get_ikev2_net_pool)
		else
			local net_pool=$(get_guest_net "${net_interface}")
		fi
		net_interface=$(get_external_interface)

		# случай основного VPN и отключенного ускорения требует дополнительной проверки
		# но именно таким код был изначально, т.е. он точно не "ухудшится"
		if ! iptables-save | grep -F 'POSTROUTING' | grep -F "${net_pool}" | grep -F "${net_interface}" | grep -Fq 'MASQUERADE' ; then
			return
		fi
		log_warning "Отключаем правила гостевого трафика для VPN без ускорения по критерию ${iptables_filter}"

		iptables -D POSTROUTING -t nat -s "${net_pool}" -o "${net_interface}" -j MASQUERADE
	fi
}

#TODO: сменить в других файлах обращение на новую обёртку
ip4_add_selected_guest_to_vpn_network() {
	ip4__add_routing_by_list_for_net "${1}"
}

#TODO: сменить в других файлах обращение на новую обёртку
ip4_add_selected_guest_to_ssr_network() {
	ip4__add_routing_by_list_for_net "${1}"
}

#TODO: сменить в других файлах обращение на новую обёртку
ip4_firewall_rm_vpn_selected_guest_net() {
	ip4__del_routing_by_list_for_net "${1}"
}

#TODO: сменить в других файлах обращение на новую обёртку
ip4_firewall_rm_ssr_selected_guest_net() {
	ip4__del_routing_by_list_for_net "${1}"
}


# ------------------------------------------------------------------------------------------
#
# Общие обёртки, добавляющие что-то
#
# ------------------------------------------------------------------------------------------

ip4_mark_vpn_network() {
	if fastnet_enabled ; then
		ip4__vpn_fast__create_chain &>/dev/null
	else
		ip4__vpn_nofast__set_rules &>/dev/null
	fi

	for guest_inface in $(get_guest_inface_list_from_config) ; do
		ip4__add_routing_by_list_for_net "${guest_inface}" &>/dev/null
	done
	if fastnet_enabled ; then
		ip4__vpn_fast__add_routing_for_home &>/dev/null
	fi
}

ip4_firewall_set_all_rules() {
	if is_shadowsocks_enabled ; then
		ip4__shadowsocks__create_chain &>/dev/null

		for guest_inface in $(get_guest_inface_list_from_config) ; do
			ip4__add_routing_by_list_for_net "${guest_inface}" &>/dev/null
		done
		ip4__shadowsocks__add_routing_for_home &> /dev/null
	elif is_vless_enabled ; then
		ip4__vless__create_chain &>/dev/null

		for guest_inface in $(get_guest_inface_list_from_config) ; do
			ip4__add_routing_by_list_for_net "${guest_inface}" &>/dev/null
		done
		ip4__vless__add_routing_for_home &> /dev/null
	else
		ip4_mark_vpn_network &>/dev/null
	fi
}


# ------------------------------------------------------------------------------------------
#
# Общие обёртки, удаляющие что-то
#
# ------------------------------------------------------------------------------------------

# для всех гостевых интерфейсов
ip4_firewall_flush_vpn_rules() {
	{
		for guest_inface in $(get_guest_inface_list_from_config) ; do
			ip4__del_routing_by_list_for_net "${guest_inface}"
		done

		if fastnet_enabled ; then
			# достаточно удалять правила для br0, но на всякий случай
			ip4__chain__delete_jump "${TABLE_MARK_TO_TABLE}" "${CHAIN_MARK_TO_TABLE}"
			# в бета 9 перехваты DNS не очищались
			#ip4__chain__delete_jump "${TABLE_DNS}" "${CHAIN_DNS}"

			# Во время работы удалять цепочки бессмысленно, они константны и не влияют ни на что
			# Достаточно убрать входы туда, что сделано выше
			# Нижеидущее нужно вызывать лишь при установке или удалении
			#ip4__chain__delete "${TABLE_MARK_TO_TABLE}" "${CHAIN_MARK_TO_TABLE}"
			#ip4__chain__delete "${TABLE_DNS}" "${CHAIN_DNS}"
		else
			# антиправила для ip4__vpn_nofast__set_rules
			iptables__delete_rules "${TABLE_MARK_TO_TABLE}" "-j MARK --set-mark ${MARK_NUM}"
		fi
	} &>/dev/null
}

# Удаляем правила iptables для ShadowSocks подключений
ip4_firewall_ssr_prune() {
	{
		for guest_inface in $(get_guest_inface_list_from_config) ; do
			ip4__del_routing_by_list_for_net "${guest_inface}" &>/dev/null
		done

		# достаточно удалять правила для br0, но на всякий случай
		ip4__chain__delete_jump "${TABLE_DNAT_TO_PORT}" "${CHAIN_DNAT_TO_PORT}"
		# в бета 9 перехваты DNS не очищались
		#ip4__chain__delete_jump "${TABLE_DNS}" "${CHAIN_DNS}"

		# Во время работы удалять цепочки бессмысленно, они константны и не влияют ни на что
		# Достаточно убрать входы туда, что сделано выше
		# Нижеидущее нужно вызывать лишь при установке или удалении
		#ip4__chain__delete "${TABLE_DNAT_TO_PORT}" "${CHAIN_DNAT_TO_PORT}"
		#ip4__chain__delete "${TABLE_DNS}" "${CHAIN_DNS}"
	} &>/dev/null
}

# Удаляем все маршрутизирующие правила iptables
ip4_firewall_flush_all_rules() {
	if is_proxy_enabled ; then
		ip4_firewall_ssr_prune
	else
		ip4_firewall_flush_vpn_rules
	fi
}

# удаляем абсолютно всё с убиванием цепочек и наборов
# необходимо при удалении или заморозки пакета
ip4__flush_full() {
	for guest_inface in $(get_guest_inface_list_from_config) ; do
		ip4__del_routing_by_list_for_net "${guest_inface}"
	done

	# достаточно для br0, но мало ли выжили от другого роутинга
	ip4__chain__delete_jump "${TABLE_DNS}" "${CHAIN_DNS}"
	# входов не осталось, саму цепочку
	ip4__chain__delete      "${TABLE_DNS}" "${CHAIN_DNS}"

	if is_proxy_enabled ; then
		ip4__chain__delete_jump "${TABLE_DNAT_TO_PORT}" "${CHAIN_DNAT_TO_PORT}"
		ip4__chain__delete      "${TABLE_DNAT_TO_PORT}" "${CHAIN_DNAT_TO_PORT}"
	elif fastnet_enabled ; then
		ip4__chain__delete_jump "${TABLE_MARK_TO_TABLE}" "${CHAIN_MARK_TO_TABLE}"
		ip4__chain__delete      "${TABLE_MARK_TO_TABLE}" "${CHAIN_MARK_TO_TABLE}"

		#ToDo: именно здесь надо удалять таблицы, их ручное удаление нужно удалить
		# ведь только эта цепочка использовала эту таблицу
		#ip4_rule_del_priority
		#ip4_flush_all_tables
	else
		iptables__delete_rules "${TABLE_MARK_TO_TABLE}" "-j MARK --set-mark ${MARK_NUM}"
	fi

	ip4__ipset__destroy_list
	ip4__ipset__destroy_reserved
}


# ------------------------------------------------------------------------------------------
#
# Всё, касающееся ip route и ip rule
#
# ------------------------------------------------------------------------------------------

# Производим очистку кэша маршрутизации
ip4_flush_cache(){
	log_warning "Проводим очистку кеша маршрутизации."
	/opt/sbin/ip route flush cache 1> /dev/null 2> "${ERROR_LOG_FILE}"
#		|| error "[${FUNCNAME}] Возникла ошибка при очистки кеша маршрутизации."
}

route_del(){
	inface_ent=${1}
	_route=$(/opt/sbin/ip route show table ${TABLE_ID})
	inface=$(echo ${_route} | grep default | cut -d' ' -f5)
	if [[ -n "${_route}" ]] && ! [[ "${inface}" = "$(inface_ent)" ]]; then
		/opt/sbin/ip route del table ${TABLE_ID} default via "$(inface_gw4)" dev $(inface_ent) &>/dev/null
	fi

}

# Создаем ip таблицу ${TABLE_ID} и копируем в нее данные из таблицы main
ip4_add_route_table(){
		
	addr_gateway=$(get_config_value "ADDR_MAN")
	_inface_ent=$(get_config_value "INFACE_ENT")
        if [[ -z "$addr_gateway" ]]; then
		_inface_cli=$(inface_cli)
		mess="Создаем таблицу маршрутизации ID#${TABLE_ID} для '${_inface_cli}'."
		log_warning "${mess}"
		ready "${mess}"

		{
		_inface_ent=$(get_config_value "INFACE_ENT")
#		rm -f "${ERROR_LOG_FILE}"
		route_del "${_inface_ent}"

		_ip_gw=$(/opt/sbin/ip a | grep global | grep "${_inface_ent}" | sed 's|.*inet \(.*\).*\/.* scope.*|\1|' | cut -d' ' -f1)

		[ -z "${_ip_gw}" ] && {
			error "Не удалось определить IP шлюза для соединения ${_inface_ent}"
			exit 1
		}

		! /opt/sbin/ip route show table ${TABLE_ID} | grep -q default && {
			if /opt/sbin/ip route add table ${TABLE_ID} default via ${_ip_gw} dev ${_inface_ent} 2>&1 | grep -vq 'File exists' ; then
				error "[${FUNCNAME}] Ошибка при создании таблицы маршрутизации ID#${TABLE_ID} для '${_inface_cli}' интерфейса."
			fi
#			log_error "${IPv4} Возникла ошибка при создании таблицы маршрутизации ID#${TABLE_ID} для '${_inface_cli}' интерфейса"
			}

#		Добавляем сеть vpn соединения.
		_net="$(echo "${_ip_gw}" | cut -d'.' -f1-3).0/24"
		if /opt/sbin/ip route add ${_net} via ${_ip_gw} table ${TABLE_ID} 2>&1 | grep -vq 'File exists' ; then
			error "[${FUNCNAME}] Ошибка при добавлении маршрута ${_net} через ${_ip_gw} в таблицу ${TABLE_ID}"
		fi

#		Проверяем на число записей в таблице ${TABLE_ID} - их должно быть больше чем одна запись
		if [ "$(/opt/sbin/ip route show table ${TABLE_ID} | grep -c dev)" -le 1 ] ; then
			_err="В таблицу с ID#${TABLE_ID} НЕ БЫЛИ скопированы записи из таблицы main!"
			error "[${FUNCNAME}] ${_err}"
		fi

		} && when_ok "УСПЕШНО" || when_bad "ОШИБКА"
		
		
		
        	else
        		mess="Создаем таблицу маршрутизации gateway ID#${TABLE_ID} для '${_inface_ent}' и шлюза ${addr_gateway}."
			log_warning "${mess}"
			ready "${mess}"

			{

			! /opt/sbin/ip route show table ${TABLE_ID} | grep -q default && {
				if /opt/sbin/ip route add table ${TABLE_ID} default via ${addr_gateway} dev ${_inface_ent} 2>&1 | grep -vq 'File exists' ; then
					error "[${FUNCNAME}] Ошибка при создании таблицы маршрутизации ID#${TABLE_ID} для '${_inface_ent}' интерфейса."
				fi
			}


#		Проверяем на число записей в таблице ${TABLE_ID} - должна быть хотя бы одна запись
			if [ "$(/opt/sbin/ip route show table ${TABLE_ID} | grep -c dev)" -le 0 ] ; then
				_err="В таблицу с ID#${TABLE_ID} НЕ БЫЛИ скопированы записи из таблицы main!"
				error "[${FUNCNAME}] ${_err}"
			fi

			} && when_ok "УСПЕШНО" || when_bad "ОШИБКА"	
		fi
}

# Устанавливаем приоритет таблицы ID#${TABLE_ID} в значение ${PRIORITY}
ip4_rule_set_priority(){

	if ! /opt/sbin/ip rule show | grep -q "fwmark ${MARK_NUM}/${MARK_NUM} lookup ${TABLE_ID}"  ; then
		log_warning "IPv4::Устанавливаем приоритет таблицы ID#${TABLE_ID} в значение ${PRIORITY}"

		if /opt/sbin/ip rule add fwmark ${MARK_NUM}/${MARK_NUM} lookup ${TABLE_ID} priority ${PRIORITY} 2>&1 | grep -vq 'File exists'; then
				error "[${FUNCNAME}] Ошибка при установке приоритета таблицы с ID#${TABLE_ID} в значение ${PRIORITY}."
		fi
                if [[ -z "$addr_gateway" ]]; then
		    if /opt/sbin/ip route add default dev $(inface_ent) table ${TABLE_ID} 2>&1 | grep -vq 'File exists' ; then
				error "[${FUNCNAME}] Ошибка при установке маршрута по умолчанию таблицы с ID#${TABLE_ID}."
		    fi
		fi
	fi

	ip4_flush_cache &>/dev/null
}

# Обнуляем приоритет таблицы ID#${TABLE_ID}
ip4_rule_del_priority(){

	if /opt/sbin/ip rule show | grep -q "fwmark ${MARK_NUM}/${MARK_NUM} lookup ${TABLE_ID}"  ; then
		log_warning "IPv4::Обнуляем приоритет таблицы ID#${TABLE_ID}"
		/opt/sbin/ip rule del fwmark ${MARK_NUM}/${MARK_NUM} lookup ${TABLE_ID} priority ${PRIORITY} &>/dev/null
#		when_error "${?}" " ${IPv4} Обнуление приоритета таблицы с ID#${TABLE_ID}"
	fi

	ip4_flush_cache &>/dev/null
}

# Удаляем все таблицы которые были созданы при работе пакета
ip4_flush_all_tables(){
	log_warning "IPv4::Производим очистку записей таблицы маршрутизации ID#${TABLE_ID} и удалим ее."
	/opt/sbin/ip route flush table "${TABLE_ID}" &>/dev/null
	/opt/sbin/ip rule del table "${TABLE_ID}"  &>/dev/null
	#when_error "${?}" " ${IPv4} Возникла ошибка при очистке таблицы маршрутизации ID#${TABLE_ID}"

	ip4_flush_cache &>/dev/null
}


# ------------------------------------------------------------------------------------------
#
# Блок функций IKEv2
# Имеют человеческий вывод, не выглядят системщиной для этого файла
#
# ------------------------------------------------------------------------------------------

ikev2_setup() {
	ikev2_data="${1}"
	enable=${2:-true}

	ikev2_dns=$(get_router_ip)
	#TODO: вынести получение параметра в функцию
	dns_server=$(echo "${ikev2_data}" | grep -F -- 'dns-server' | cut -d':' -f2 | sed 's/[\,\" ]//g;')
	enable=$(echo "${ikev2_data}"     | grep -F    'enable'     | cut -d':' -f2 | sed 's/[\,\" ]//g;')
	nat=$(echo "${ikev2_data}"        | grep -F    'nat'        | cut -d':' -f2 | sed 's/[\,\" ]//g;')
	if [ "${dns_server}" != "${ikev2_dns}" ] || [ "${enable}" != true ] || [ "${nat}" != true ] ; then
		# Если DNS отличен от IP роутера, или интерфейс, или NAT отключены
		pool_size=$(echo "${ikev2_data}"   | grep -F -- 'pool-size'   | cut -d':' -f2 | sed 's/[\,\" ]//g;')
		pool_start=$(echo "${ikev2_data}"  | grep -F -- 'pool-start'  | cut -d':' -f2 | sed 's/[\,\" ]//g;')
		multi_login=$(echo "${ikev2_data}" | grep -F -- 'multi-login' | cut -d':' -f2 | sed 's/[\,\" ]//g;')
		sa_compat=$(echo "${ikev2_data}"   | grep -F -- 'sa-compat'   | cut -d':' -f2 | sed 's/[\,\" ]//g;')

		curl -s -d '{"enable": '"${enable}"', "nat": true, "dns-server": "'"${ikev2_dns}"'", "pool-size": "'"${pool_size}"'", "pool-start": "'"${pool_start}"'", "multi-login": "'"${multi_login}"'", "sa-compat": "'"${sa_compat}"'"}' \
		 "${LOCALHOST_IP}:79/rci/crypto/virtual-ip-server-ikev2" &> /dev/null
		sleep 1
	fi
}

del_all_net_from_config(){
        sed -i 's/\(INFACE_GUEST_ENT=\).*/\1/; s/[ ,]//g' "${KVAS_CONF_FILE}"
}

del_ikev2_net_from_config(){
		has_guest_nets=$(cat <  "${KVAS_CONF_FILE}" | sed -n 's/INFACE_GUEST_ENT=\(.*\)/\1/p;'| sed 's/[ ,]//g')
        [ -n "${has_guest_nets}" ] && point=',' || point=''
        sed -i '/INFACE_GUEST_ENT=/,/^$/ s/ikev2[,]\{0,1\}//; s/[ ]//g' "${KVAS_CONF_FILE}"
}

add_ikev2_net_to_config(){
        has_guest_nets=$(cat <  "${KVAS_CONF_FILE}" | sed -n 's/INFACE_GUEST_ENT=\(.*\)/\1/p;'| sed 's/[ ]//g')
        [ -n "${has_guest_nets}" ] && point=',' || point=''
        del_ikev2_net_from_config
        sed -i "s/\(INFACE_GUEST_ENT=.*\)/\1${point}ikev2/g; s/[ ]//g" "${KVAS_CONF_FILE}"
}

ikev2_net_access_add() {
	local ikev2_settings=$(curl -s "${LOCALHOST_IP}:79/rci/crypto/virtual-ip-server-ikev2")

	# вероятное изменение настроек роутера
	ikev2_setup "${ikev2_settings}"

	local net_pool=$(echo "${ikev2_settings}" | grep -F -- 'pool-start' | cut -d':' -f2 | sed 's/[\,\" ]//g;')
	ready "Добавление гостевого интерфейса \"VPN-сервер IKEv2\" [${net_pool}] завершено" && {
		ip4__add_routing_by_list_for_net 'ikev2'

		# сохранение в конфигурацию КВАС
		add_ikev2_net_to_config
	} && when_alert "УСПЕШНО" || when_bad "С ОШИБКОЙ"
}

ikev2_net_access_del() {
	ready "Удаление интерфейса \"VPN-сервер IKEv2\" завершено" && {
		ip4__del_routing_by_list_for_net 'ikev2'
	} && when_alert "УСПЕШНО" || when_bad "С ОШИБКОЙ"
}


# ------------------------------------------------------------------------------------------
#
# 	Вызываются из файла vpn, правильнее унести туда же
# 	Имеют человеческий вывод, не выглядят системщиной для этого файла
#
# ------------------------------------------------------------------------------------------

# Чистим и заполняем таблицу правил iptables для vpn подключений
cmd_vpn_iptable_reset() {
	if [ -f /opt/etc/ndm/fs.d/100-vpn ] ; then
		ready "Переустановка iptables для vpn завершена"
		{
			cmd_vpn_iptable_flush  #&> /dev/null

			ip4_add_route_table #&> /dev/null
			ip4_rule_set_priority #&> /dev/null

			ip4_mark_vpn_network #&> /dev/null
		} &> /dev/null && when_ok "УСПЕШНО" || when_bad "C ОШИБКАМИ"
	else
		warning "VPN соединение не активно!"
	fi
}

# Чистим таблицу правил iptables для vpn подключений
cmd_vpn_iptable_flush() {
	ready "Очистка iptables для vpn завершена"
	ip4_firewall_flush_vpn_rules && when_ok "УСПЕШНО" || when_bad "C ОШИБКАМИ"
}

# Пересоздаем все ранее созданные таблицы для утилит ipset и ip
recreate_ip4tables(){

	ready "${prefix}Удаляем все ранее созданные таблицы для утилит ipset и ip"
	ip4_flush_all_tables &>/dev/null && when_ok "УСПЕШНО" || when_bad "ОШИБКА"

#	ready "${prefix}Создаем таблицу маршрутизации ID#${TABLE_ID} для '$(inface_cli)'."
#	#	Создаем таблицу IP адресов для  VPN подключения отличного от shadowsocks
#	ip4_add_route_table &> /dev/null
#	[ $? = 0 ] && when_ok "УСПЕШНО" || when_bad "ОШИБКА"
}

# Пересоздаем все необходимые правила для корректной работы VPN соединения
recreate_vpn_rules(){
	ready "${prefix}Очищаем все ранее созданные iptables правила для VPN."
	ip4_firewall_flush_all_rules  &>/dev/null
	when_ok "УСПЕШНО"

	ready "${prefix}Обнуляем приоритет таблицы ID#${TABLE_ID}"
	ip4_rule_del_priority &>/dev/null && when_ok "УСПЕШНО" || when_bad "ОШИБКА"

	ready "${prefix}Устанавливаем приоритет таблицы ID#${TABLE_ID} в значение ${PRIORITY}"
	# Устанавливаем приоритет таблицы
	ip4_rule_set_priority &> /dev/null && when_ok "УСПЕШНО" || when_bad "ОШИБКА"

	ready "${prefix}Создаем iptables правила для VPN соединения."
	# Создаем правила iptables
	ip4_mark_vpn_network &> /dev/null && when_ok "УСПЕШНО" || when_bad "ОШИБКА"
}

# Пересоздаем все необходимые правила для корректной работы SHADOWSOCKS соединения
recreate_ssr_rules(){
	ready "${prefix}Очищаем все ранее созданные iptables правила для ShadowSocks."
	ip4_firewall_ssr_prune &>/dev/null && when_ok "УСПЕШНО" || when_bad "ОШИБКА"

	ready "${prefix}Создаём цепочку для ShadowSocks соединения."
	ip4__shadowsocks__create_chain &> /dev/null && when_ok "УСПЕШНО" || when_bad "ОШИБКА"

	ready "${prefix}Создаём правила домашней сети для ShadowSocks."
	ip4__shadowsocks__add_routing_for_home &> /dev/null && when_ok "УСПЕШНО" || when_bad "ОШИБКА"

	ready "${prefix}Создаём правила гостевых сетей для ShadowSocks."
	for guest_inface in $(get_guest_inface_list_from_config) ; do
		ip4__add_routing_by_list_for_net "${guest_inface}" &>/dev/null
	done && when_ok "УСПЕШНО" || when_bad "ОШИБКА"
}

# Пересоздаем таблицу ipset для AdGuard Home и перезапускаем сервис
refresh_adguard_ipset_table(){
	ready "${prefix}Заполняем AdGuard таблицу данными из защищенного списка."
	/opt/apps/kvas/bin/main/adguard &>/dev/null && when_ok "УСПЕШНО" || when_bad "ОШИБКА"
}


# ------------------------------------------------------------------------------------------
#
# Функции для поддержки протокола ip6
#
# ------------------------------------------------------------------------------------------
ip6() (/opt/sbin/ip -6 "$@")
ip6tables() (if ! /opt/sbin/ip6tables -C "$@" &>/dev/null; then ip6tables -A "$@"; fi)
ip6save() (/opt/sbin/ip6tables-save)

ip6set_create_table(){
	ttl_timeout=$(get_config_value TTL_TIMEOUT)
	ipset create "${IPSET_TABLE_NAME}6" hash:net family inet6 -exist timeout ${ttl_timeout} &>/dev/null \
	 || {
			_err="${IPv6}Возникла ошибка при создании таблицы с именем '${IPSET_TABLE_NAME}' для ipset"
			error "[${FUNCNAME}] ${_err}"
		}
}
